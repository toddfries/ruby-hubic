#!/usr/bin/env ruby

require 'rubygems'
require 'optparse'
require 'hubic'
require 'highline'
require 'ostruct'
require 'mime/types'


HUBIC_CLIENT_CFG = "#{ENV['HOME']}/.hubic-client"

exclusive_options = []
container = nil
user      = ENV['HUBIC_USER']

error_proc = lambda do |msg|
  $stderr.puts(msg)
  exit 1
end

verb = 0

options = OptionParser.new do |opts|
    opts.banner = "Hubic: access your data"
    opts.define_head "Usage: hubic [options] <uri|path> [file]"
    opts.separator ""
    opts.separator "Examples:"
    opts.separator "  HUBIC_USER=foo@bar.com"
    opts.separator "  hubic client   config"
    opts.separator "  hubic auth"
    opts.separator "  hubic mkdir [-p] cloud"
    opts.separator "  hubic upload     local-file.txt cloud/cloud-file.txt"
    opts.separator "  hubic md5        cloud/cloud-file.txt"
    opts.separator "  hubic download   cloud/cloud-file.txt"
    opts.separator "  hubic delete     cloud/cloud-file.txt"
    opts.separator "  hubic list [-al] cloud"
    opts.separator "  hubic ls   [-al] cloud"
    opts.separator "  hubic du         cloud"
    opts.separator ""
    opts.separator "Options:"
    
    opts.on_tail("-h", "--help", "Show this message") do
        puts opts
        exit
    end
    
    opts.on("-c", "--container STRING", "Use the give container as default") do  |v|
        container = v
        exclusive_options << :container
    end
    

    opts.on("-u", "--user STRING", "User account to use") do  |v|
        user = v
    end

    opts.on("-V", "--verbose", "Be verbose about action performed") do
        require 'logger'
        loggers << Logger.new($stdout)
        verb += 1
    end
  
    opts.on_tail("-v", "--version", "Show version") do
        puts "Hubic #{Hubic::VERSION}"
        exit
    end
end
opts = options
opts.parse!

$term = HighLine.new

action = ARGV.shift

# Manage client configuration
if action == 'client'
    case ARGV[0]
    when 'config'
        ARGV.shift
        cfg = case ARGV.length
              when 0
                  [ $term.ask("Client ID    : ").to_s,
                    $term.ask("Client Secret: ").to_s,
                    $term.ask("Redirect URI : ").to_s ]
              when 3
                  ARGV
              else
                  error_proc["hubic client config [client_id client_secret_ redirect_uri"]
              end
        File.open(HUBIC_CLIENT_CFG, 'w', 0600) {|io|
            io.write({ 'client_id'     => cfg[0],
                       'client_secret' => cfg[1],
                       'redirect_uri'  => cfg[2], }.to_yaml)
        }
        exit
    when 'reset'
        File.unlink(HUBIC_CLIENT_CFG)
        exit
    end
end


# Configure Hubic client
if ENV.include?('HUBIC_REDIRECT_URI' ) &&
   ENV.include?('HUBIC_CLIENT_ID'    ) &&
   ENV.include?('HUBIC_CLIENT_SECRET')
    Hubic.default_redirect_uri  = ENV['HUBIC_REDIRECT_URI' ]
    Hubic.default_client_id     = ENV['HUBIC_CLIENT_ID'    ]
    Hubic.default_client_secret = ENV['HUBIC_CLIENT_SECRET']
else
    begin
        cfg = YAML.load_file(HUBIC_CLIENT_CFG)
        Hubic.default_redirect_uri  = cfg['redirect_uri' ] 
        Hubic.default_client_id     = cfg['client_id'    ] 
        Hubic.default_client_secret = cfg['client_secret'] 
    rescue Errno::ENOENT
        error_proc["Plase run: hubic client config"]
    end
end

if user.nil?
    raise "User required!"
end

def du_recurse(user, obj)
    tsize = 0
    Hubic.for_user(user).list(obj).each {|path, meta|
        path = path.split('/')[-1] if obj
        if meta[:type] == 'application/directory'
            size = du_recurse(user, "#{obj}/#{path}")
            astr = '/'
        else
            size = meta[:size]
            astr = ''
        end
        tsize += size
        #if verb > 0
            puts "+%10d = %10d %s%s" % [ size, tsize, "#{obj}/#{path}", astr ]
        #end
    }
    tsize
end

case action
when 'auth'
    Hubic.for_user(user, ARGV[0], force: true) {|user|
        ($term.ask("Password for #{user}: ", String) {|q| q.echo = 'x' }).to_s
    }
when 'download' # hubic / local
    obj = ARGV[0]
    dst = ARGV[1] || File.basename(obj)
    Hubic.for_user(user).download(obj, dst)
when 'upload'   # local / hubic
    src = ARGV[0]
    obj = ARGV[1]
    Hubic.for_user(user).upload(src, obj)
when 'mkdir'
    ARGV.each {|obj|
        Hubic.for_user(user).mkdir(obj, parents: false)
    }
when 'mkdir_p'
    ARGV.each {|obj|
        Hubic.for_user(user).mkdir(obj, parents: true)
    }
when 'md5'
    ARGV.each {|obj|
        puts Hubic.for_user(user).md5(obj)
    }
when 'list', 'ls'

    copts = OpenStruct.new
    OptionParser.new {|opts|
        opts.on("-l", "long") do  |v|
            copts.long = true
        end
        opts.on("-a", "all") do  |v|
            copts.all  = true
        end
    }.parse!
    
    ARGV.each {|obj|
    
        Hubic.for_user(user).list(obj).each {|file, meta|
            file = file.split('/')[-1] if obj

            next if !copts.all && file[0] == ?. 

            if meta[:type] != 'application/directory'
                type = :file
            else
                type = :directory
            end
            time = meta[:lastmod].strftime("%Y-%m-%d %H:%M")
            hash = meta[:hash]
            size = meta[:size]

            astr = ''
            case type
            when :directory
                hash = '-'
                astr = '/'
                stype = 'd'
            when :file
                stype = '-'
            else
                stype = '?'
            end

            
            if copts.long
                puts "%s %-32s %10d %s %s" % [ stype, hash, size, time, file ]
            else
                puts "%s%s" % [ file, astr ]
            end
        }
    }
when 'du'
    ARGV.each {|obj|
        total_size = du_recurse(user, obj)
        puts "%10d %s" % [ total_size, obj ]
    }
when 'delete'
    obj = ARGV[0]
    if obj.nil?
        raise "You must provide the path as the first argument"
    end
    ARGV.each {|obj|
        Hubic.for_user(user).delete(obj)
    }
else
    $stderr.puts "Unknown command"
    exit(1)
end
